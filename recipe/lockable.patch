From 8a50c7edc16df5f0c634747a0043a5e9ee04c784 Mon Sep 17 00:00:00 2001
From: Jan Janssen <jan-janssen@users.noreply.github.com>
Date: Tue, 20 Aug 2024 20:26:00 +0200
Subject: [PATCH] Backwards compatible access to executable name during
 instantiate (#1612)

* Only pass known keys to Server dataclass

* Backwards compatible access to executable name during instantiate

* Add backwards compatibility when restoring server/executable

---------

Co-authored-by: Marvin Poul <poul@mpie.de>
---
 pyiron_base/jobs/job/extension/executable.py     |  6 +++++-
 pyiron_base/jobs/job/extension/server/generic.py | 11 ++++++-----
 pyiron_base/jobs/job/generic.py                  | 15 +++++++++++++--
 3 files changed, 24 insertions(+), 8 deletions(-)

diff --git a/pyiron_base/jobs/job/extension/executable.py b/pyiron_base/jobs/job/extension/executable.py
index 034d40fa4..b2417d744 100644
--- a/pyiron_base/jobs/job/extension/executable.py
+++ b/pyiron_base/jobs/job/extension/executable.py
@@ -208,7 +208,11 @@ def executable_path(self, new_path):
 
     @classmethod
     def instantiate(cls, obj_dict: dict, version: str = None) -> "Self":
-        return cls(codename=obj_dict["name"])
+        try:
+            codename = obj_dict["name"]
+        except KeyError:
+            codename = obj_dict["executable"]["name"]
+        return cls(codename=codename)
 
     def _to_dict(self):
         return asdict(self.storage)
diff --git a/pyiron_base/jobs/job/extension/server/generic.py b/pyiron_base/jobs/job/extension/server/generic.py
index a08fc7cc8..df4b4f44d 100644
--- a/pyiron_base/jobs/job/extension/server/generic.py
+++ b/pyiron_base/jobs/job/extension/server/generic.py
@@ -8,7 +8,7 @@
 import numbers
 import socket
 from concurrent.futures import Executor, Future
-from dataclasses import asdict
+from dataclasses import asdict, fields
 from typing import Union
 
 from pyiron_snippets.deprecate import deprecate
@@ -564,7 +564,6 @@ def view_queues():
     def _to_dict(self):
         self._data.run_mode = self._run_mode.mode
         return asdict(self._data)
-        return server_dict
 
     def _from_dict(self, obj_dict, version=None):
         # backwards compatibility
@@ -578,9 +577,11 @@ def _from_dict(self, obj_dict, version=None):
         if "additional_arguments" not in obj_dict.keys():
             obj_dict["additional_arguments"] = {}
 
-        # Reload dataclass
-        for key in ["NAME", "TYPE", "OBJECT", "VERSION", "DICT_VERSION"]:
-            if key in obj_dict.keys():
+        # Reload dataclass and discard unknown keys
+        server_fields = tuple(f.name for f in fields(ServerDataClass))
+        # force tuple otherwise dict complains about changing size
+        for key in tuple(obj_dict):
+            if key not in server_fields:
                 del obj_dict[key]
         self._data = ServerDataClass(**obj_dict)
         self._run_mode = Runmode(mode=self._data.run_mode)
diff --git a/pyiron_base/jobs/job/generic.py b/pyiron_base/jobs/job/generic.py
index aa2a85426..a9107f624 100644
--- a/pyiron_base/jobs/job/generic.py
+++ b/pyiron_base/jobs/job/generic.py
@@ -1178,9 +1178,20 @@ def _from_dict(self, obj_dict, version=None):
         self._type_from_dict(type_dict=obj_dict)
         if "import_directory" in obj_dict.keys():
             self._import_directory = obj_dict["import_directory"]
-        self._server = obj_dict["server"]
+        # Backwards compatibility: Previously server and executable were stored
+        # as plain dicts, but now they are dicts with additional info so that
+        # HasDict can load them automatically.
+        # We need to check whether that was possible with the instance check
+        # below and if not, call from_dict ourselves.
+        if isinstance(server := obj_dict["server"], Server):
+            self._server = server
+        else:
+            self._server.from_dict(server)
         if "executable" in obj_dict.keys() and obj_dict["executable"] is not None:
-            self._executable = obj_dict["executable"]
+            if isinstance(executable := obj_dict["executable"], Executable):
+                self._executable = executable
+            else:
+                self.executable.from_dict(executable)
         input_dict = obj_dict["input"]
         if "generic_dict" in input_dict.keys():
             generic_dict = input_dict["generic_dict"]
